#!/usr/bin/env zsh

str-array-member-p () {
  local array=$1
  local match=0

  for member in ${(P)${array}}; do
    if [[ $2 == $member ]]; then
      match=1
      break
    fi
  done

  echo $match
}

diff-str-arrays () {
  local array1=$1
  local array2=$2
  local result=()
  local -i match

  for ele in ${(P)${array1}}; do
    match=0

    for el in ${(P)${array2}}; do
      [[ $ele == $el ]] && match=1
    done

    [[ $match -eq 0 ]] && result+=$ele
  done

  echo $result
}

rand-arg () {
  [[ $# -eq 0 ]] && return 0

  if [[ $# -eq 1 ]]; then
    echo "$1"
  else
    local rand=$((1 + $RANDOM % $#))
    echo $@[$rand]
  fi
}

set-wall () {
  $cmd $cmd_opts "$1"
  curwall="$1"
  [[ $(str-array-member-p "used_walls" $curwall) -eq 0 ]] && used_walls+=("$1")
}

next () {
  local active_walls=($(echo $walls/$active_dirname/**/*(@N)))
  local active_len=${#active_walls[@]}

  if [[ $active_len -gt 0 ]]; then
    if [[ $active_len -eq 1 ]]; then
      set-wall "$active_walls[1]"
    else
      local available_walls=($(diff-str-arrays "active_walls" "used_walls"))
      local available_len=${#available_walls[@]}

      # Loop over to use previously used wallpapers again if there's no unused
      # ones to pick from.
      if [[ $available_len -eq 0 ]]; then
        available_walls=$active_walls
        available_len=${#available_walls[@]}
        used_walls=()
      fi

      if [[ $shuffle -eq 1 ]]; then
        set-wall $(rand-arg $available_walls)
      else
        local match=0
        local set_p=0

        for wall in $active_walls; do
          if [[ $match -eq 1 ]]; then
            set-wall "$wall"
            set_p=1
            break
          fi

          [[ $wall == $curwall ]] && match=1
        done

        [[ $set_p -eq 0 ]] && set-wall "$active_walls[1]"
      fi
    fi
  fi
}

prev () {
  local used_len=${#used_walls[@]}

  if [[ $used_len -eq 0 ]] || [[ $used_len -eq 1 ]]; then
    next
  else
    local used_walls_rev=(${(Oa)used_walls})
    local match=0
    local set_p=0

    for wall in $used_walls_rev; do
      if [[ $match -eq 1 ]]; then
        set-wall "$wall"
        set_p=1
        break
      fi

      [[ $wall == $curwall ]] && match=1
    done

    [[ $set_p -eq 0 ]] && set-wall "$used_walls_rev[1]"
  fi
}

start-slideshow () {
  while :; do
    sleep $interval
    next
  done
}

stop-slideshow () {
  if [[ -n $REPLY ]]; then
    kill $REPLY
    REPLY=''
  fi
}

subdirs () {
  local filename=$(basename "$1")
  local subdirs=${1#$2/}
  echo ${subdirs%/$filename}
}

add () {
  local subdirs=$(subdirs "$1" "$walls")
  local link="$walls/$active_dirname/$subdirs/$(basename $1)"

  if [[ -f "$1" ]]; then
    mkdir -p "$walls/$active_dirname/$subdirs"
    [[ -L "$link" ]] || ln -s "$1" "$link"
  fi
}

# Symlinks arguments to active directory. Directories are recursively expanded
# to their contents.
activate () {
  for file in $@; do
    if [[ ${file:0:1} != '/' ]]; then
      file="$walls/$file"
    else
      [[ "$file" =~ "$walls" ]] || continue
    fi

    if [[ -d "$file" ]]; then
      [[ "$file" != "$walls/$active_dirname" ]] && activate $file/*(N)
    else
      if [[ ${#filetypes[@]} -eq 0 ]]; then
        add "$file"
      else
        for filetype in $filetypes; do
          if [[ "$file" == *.$filetype ]]; then
            add "$file"
            break
          fi
        done
      fi
    fi
  done
}

remove () {
  if [[ -L "$1" ]]; then
    local subdirs=$(subdirs "$1" "$walls/$active_dirname")
    rm "$1"

    if [[ -n "$subdirs" ]]; then
      cd "$walls/$active_dirname"
      rmdir --ignore-fail-on-non-empty -p "$subdirs"
    fi
  fi
}

deactivate () {
  for file in $@; do
    if [[ ${file:0:1} != '/' ]]; then
      file="$walls/$active_dirname/$file"
    else
      [[ "$file" =~ "$walls/$active_dirname" ]] || continue
    fi

    if [[ -d "$file" ]]; then
      deactivate $file/*(N)
    else
      remove "$file"
    fi
  done
}

main () {
  . $BIN_CONFIG_HOME/wpd

  # Exit with error if $fifo file already exists but isn't a pipe. Otherwise
  # create pipe if it doesn't exist.
  [[ -p $fifo ]] || ([[ -f $fifo ]] && exit 1 || mkfifo $fifo)

  mkdir -p "$walls/$active_dirname"
  used_walls=()
  curwall=''

  while :; do
    args=$(<$fifo)
    args=${(z)args}

    case "${args:0:1}" in
      ':')
        stop-slideshow
        rm $fifo
        break
        ;;
      '=')
        echo $cmd $cmd_opts wall
        ;;
      '_')
        [[ $shuffle -eq 0 ]] && shuffle=1 || shuffle=0
        ;;
      '.')
        next
        ;;
      ',')
        prev
        ;;
      '+')
        if [[ -n ${args:1:2} ]]; then
          if [[ ${args:1:2} -eq 0 ]]; then
            stop-slideshow
          else
            stop-slideshow
            interval=${args:1:2}
            # PID of start-slideshow subshell is stored in $REPLY variable.
            read < <(start-slideshow & echo $!)
          fi
        else
          if [[ -z $REPLY ]]; then
            read < <(start-slideshow & echo $!)
          else
            stop-slideshow
          fi
        fi
        ;;
      '!')
        [[ -z ${args:1} ]] && deactivate "$walls/$active_dirname" \
                           || deactivate ${args:1}
        ;;
      *)
        [[ -z $args ]] && activate "$walls" || activate $args
        ;;
    esac
  done
}

main
